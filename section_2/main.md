# 学习 Verilog语法 hdl i guess

最小单位 module

```hdl
module name();

endmodule
```

四种基本值表示逻辑

0 假

1 真

x 意味着信号数值的不确定，即在实际电路里，信号可能为 1，也可能为 0。

z 意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 pad 的 input 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0 。

整数数值表示方法

十进制 十六进制 二进制 八进制
十进制('d 或 'D)，十六进制('h 或 'H)，二进制（'b 或 'B），八进制（'o 或 'O

指明位宽

4'b1011         // 4bit 数值

32'h3022_c0de   // 32bit 的数值

不指明位宽

默认是十进制数字

counter = 'd100
counter = 100
counter = 32'h64

负数

放在位宽之前

-6'd15

-15

实数表示方法

十进制表示 
12.0
13.0

科学记数法

1.2e4 // == 1.2 * 10^4

1E-3 // == 1 * 10^-3

字符串表示方法

字符串里不能换行，不能有回车符

每个字符需要 8bit存储

--------

Verilog数据类型

wire(线网) 

wire 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 "Z"

```hdl
wire interrupt;
wire flag1, flag2; 
wire gnd = 1'b0
```

线网还包括其他的数据类型 wand，wor，wri，triand，trior，trireg 等 但使用频率不高

reg (寄存器)

寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：

```hdl
reg clk_temp;
reg flag1, flag2;
```

寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写

向量

但位宽大于1的时候，wire 和 reg 可以被声明为向量形式

```hdl
reg [3:0]      counter ;    //声明4bit位宽的寄存器counter
wire [32-1:0]  gpio_data;   //声明32bit位宽的线型变量gpio_data
wire [8:2]     addr ;       //声明7bit位宽的线型变量addr，位宽范围为8:2
reg [0:31]     data ;       //声明32bit位宽的寄存器变量data, 最高有效位为0
```

左右都包含

对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如：

```hdl
wire [9:0]     data_low = data[0:9] ;
addr_temp[3:2] = addr[8:7] + 1'b1 ;
```

[从高位: 到低位]

reg[3:0] reg[3]是高位 reg[0]是低位
reg[0:3] reg[0]是高位 reg[3]是低位


基本上所有情况都是高位到低位, 习惯上左高右低


电路上来看

reg [9:0] data;


 data[9] ────┐
 data[8] ────┤
 data[7] ────┤
 data[6] ────┤
 data[5] ────┤  ← 这些并不是 10 个“存储格”
 data[4] ────┤     而是 10 条“并联信号线”
 data[3] ────┤     一起组成一个“总线（bus）”
 data[2] ────┤
 data[1] ────┤
 data[0] ────┘

是并行的，不是数组那样

wire 就是一根导线, 把不同元件连接起来

wire 只能被“驱动”，不能自己保存值。
就是说，它不能像变量一样记住上一次的状态。

所以不要想成变量，就是一根线

wire gnd = 1'b0; 不是给 gnd 存值

它只是把 gnd 永远连到逻辑 0

电路中没有寄存器，也不会在时钟上改变


举个例子

wire [31:0] gnd = 32'b100000001;

wire [31:0] gnd 声明一个 32 位宽的总线（总共 32 根并行导线）

= 32'b100000001; → 给这个总线赋初值/连续赋值，每一根导线对应一个比特

32 根导线并排组成总线

每根导线被 常量 0 或 1 驱动

wire 没有存储能力，它只是导线被固定电平驱动


 Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。

    [bit+: width] : 从起始 bit 位开始递增，位宽为 width。
    [bit-: width] : 从起始 bit 位开始递减，位宽为 width。 

//下面 2 种赋值是等效的
A = data1[31-: 8] ;
A = data1[31:24] ;

//下面 2 种赋值是等效的
B = data1[0+ : 8] ;
B = data1[0:7] ;

wire [31:0]    temp1, temp2 ;
assign temp1 = {byte1[0][7:0], data1[31:8]};  //数据拼接
assign temp2 = {32{1'b0}};  //赋值32位的数值0

--------

整数，实数，时间寄存器变量

都属于寄存器的分支

整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。

integer 常用来仿真，一般不写入电路

实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。

64 位 IEEE 浮点数（双精度）

只能在 仿真环境 使用，不能综合成硬件

常用于模拟信号建模（例如电压、电流、浮点运算）

Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。例如：

64 位 无符号整数

用来存放 仿真时间值（单位：time unit，比如 ns、ps）

常用于测量延迟、间隔等仿真时间

这几个都是仿真，电路里没有

--------

数组


数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用

就是一捆线组成的更大的一捆线

存储器

寄存器数组, 可以用来描述RAM或者ROM行为

```hdl
reg               membit[0:255] ;  //256bit的1bit存储器
reg  [7:0]        mem[0:1023] ;    //1Kbyte存储器，位宽8bit
mem[511] = 8'b0 ;                  //令第512个8bit的存储单元值为0
```


--------

参数

 参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：

```hdl
parameter      data_width = 10'd32 ;
parameter      i=1, j=2, k=3 ;
parameter      mem_size = data_width * 10 ;
```


不会被刻录电路里，但他的值可能会影响电路的刻录

当成常量就好了



--------

字符串

字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。

特殊的字符需要转义符号 "\" 

--------

操作符

--------
和C基本一样

同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。

算数操作符

算术操作符包括单目操作符和双目操作符。

双目操作符对 2 个操作数进行算术运算，包括乘（*）、除（/）、加（+）、减（-）、求幂（**）、取模（%）。

如果操作数某一位为 X，则计算结果也会全部出现 X

```hdl
b = 4'b100x ;
c = a+b ;       //结果为c=4'bxxxx
```

按位操作符

取反（~），与（&），或（|），异或（^），同或（~^）


--------

```
    always @(posedge clk) begin // 当时钟信号 clk 从低电平跳变到高电平（0 → 1） 时，执行一次括号里的逻辑
        if (count >= COUNT_MAX - 1) begin
            count <= 0;
            led <= ~led;             // 翻转 LED 状态
        end else begin
            count <= count + 1;
        end
    end
```

posedge 就是 positive edge（上升沿）的缩写。

negedge —— negative edge（下降沿，1 → 0）

@(*)
任意输入变化时立即执行（组合逻辑）


parameter 在实例化时可以改变，
localparam 只能模块内部用，外部无法修改。

1. 在 仿真代码 / testbench 中，# 用来表示“延时”。

2. 参数化实例化符号（parameter override）

在 模块实例化 时，#() 用来给模块的 parameter 传值：

延时用在仿真，实例化用在模块参数
--------

实例化就是在顶层模块或 testbench 中，把一个模块蓝图“放进电路”，创建具体模块对象，并连接它的输入输出信号。


<= 是非阻塞赋值，用于时序逻辑，让寄存器在时钟沿结束后统一更新，保证多寄存器同步更新而不依赖顺序。

Verilog 赋值有阻塞（=）、非阻塞（<=）、连续(assign) 和参数赋值(parameter/localparam) 四类，分别用于组合逻辑、时序逻辑、信号连接和模块常量。

阻塞赋值 = 

立即更新，顺序执行

```hdl
always @(*) begin
    out = a & b;
    out2 = out | c; // 使用更新后的 out
end
```


clk: ──┐─┐─┐─┐
        ↑ ↑ ↑ ↑
b:   ──1──0──1──0
a:   ──1──0──1──0
c:   ──1──1──0──1

非阻塞赋值 <= 

在时钟沿结束后统一更新，保证同步

```hdl
always @(posedge clk) begin
    a <= b;
    c <= a;
end
```

clk: ──┐─┐─┐─┐
        ↑ ↑ ↑ ↑
b:   ──1──0──1──0
a:   ──0──1──0──1  (下一时钟沿才更新)
c:   ──0──0──1──0  (使用上一个 a 的值)

连续赋值 assign

```hdl
wire a;
assign a = b & c;
```

b: ──1────0────1
c: ──0────1────0
a: ──0────0────0  (输入变化立即更新)


| 特性             | `assign`   | `=`           |
| -------------- | ---------- | ------------- |
| 对象类型           | wire       | reg           |
| 必须在 always 块内吗 | ❌ 不需要      | ✅ 需要          |
| 更新时机           | 输入变化立即更新   | 顺序执行（阻塞）      |
| 使用场景           | 组合逻辑、模块间连线 | 组合逻辑内部计算、临时变量 |


assign 只能用于 wire

--------

仿真模块/顶层模块（testbench)


| 特性         | initial            | always                           |
| ---------- | ------------------ | -------------------------------- |
| 执行次数       | 仅一次                | 无限循环（每次触发执行一次）                   |
| 用途         | 初始化、testbench控制、仿真 | 时序逻辑、组合逻辑、周期性信号                  |
| 是否可以有触发条件  | ❌ 没有               | ✅ 可以使用 `@(*)` 或 `@(posedge clk)` |
| 可以使用 `#延时` | ✅                  | ✅（通常用于 testbench）                |


$ system task  

| 系统任务        | 作用                           |
| ----------- | ---------------------------- |
| `$finish`   | 结束仿真                         |
| `$stop`     | 暂停仿真，仿真器停在当前位置，方便调试          |
| `$time`     | 返回当前仿真时间（单位由 `timescale` 决定） |
| `$realtime` | 返回当前仿真时间，精度为浮点               |
| `$display`  | 打印信息到控制台（一次性打印）              |
| `$monitor`  | 自动监控信号变化，每次变化都会打印            |
| `$write`    | 类似 `$display`，但不会换行          |
| `$fdisplay` | 打印到文件                        |
| `$fmonitor` | 监控信号变化并打印到文件                 |
| `$fwrite`   | 文件打印，不换行                     |


| 系统任务                       | 作用               |
| -------------------------- | ---------------- |
| `$dumpfile("file.vcd")`    | 指定波形输出文件名        |
| `$dumpvars(level, module)` | 保存模块及其信号到 VCD 文件 |


| 系统任务                | 作用                             |
| ------------------- | ------------------------------ |
| `#10`               | 延时 10 时间单位（不是 $ 开头，但常和系统任务一起用） |
| `$finish` / `$stop` | 控制仿真结束或暂停                      |



| 系统任务                          | 作用                            |
| ----------------------------- | ----------------------------- |
| `$random`                     | 生成随机数                         |
| `$signed` / `$unsigned`       | 类型转换                          |
| `$clog2`                      | 返回对数，用于计算数组大小等（Verilog 2001+） |
| `$bitstoreal` / `$realtobits` | 类型转换（real ↔ bits）             |


$ 开头的都是 仿真/系统任务

不能综合成硬件，只能在 testbench 或仿真中使用

input：只读 → wire

output：如果在 always 块中赋值 → reg

output：如果用 assign 组合逻辑 → wire

--------


always @(posedge clk) 的作用与性质
作用

always @(posedge clk) 表示在时钟上升沿触发

常用于实现寄存器型逻辑（同步逻辑）

每个时钟上升沿都会执行 always 里的代码

性质

硬件触发器对应

对应 D 触发器或寄存器阵列

reg 类型信号在时钟沿更新

状态机基础

状态机状态寄存器、bit_index、shift_reg 等都放在 always @(posedge clk) 里更新

clk 只是驱动

实际发送数据的节奏通常由 tick 控制

clk 决定逻辑检查频率，但输出更新只在 tick 条件满足时发生

也有typedef enum {} name;

还有struct 什么的
